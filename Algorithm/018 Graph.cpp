// 그래프 ( Graph )
/*
* (무방향) 그래프  G = (V,E)						각 노드들마다 연결되는 링크가 여러개일 수 있으며, 링크의 방향이 있지 않다. (양뱡향 둘다 ㅇ)     Ex) 에지 (u,v) == (v,u)
*	* V : 노드 혹은 정점
	* E : 노드쌍을 연결하는 에지 혹은 링크
	* 개체간의 이진관계를 표현한다.
	* n = |V| , m = |E|
	* 무방향 그래프에서 노드와 노드를 연결하는 경로가 존재하는 경우, v,u가 서로 연결되어있다고 한다.
	* 모든 노드들이 쌍으로 서로 연결되어있는 그래프를 "연결그래프"라고 한다.

* 방향 그래프  G = (V,E)							각 노드들마다 연결되는 링크가 여려개일 수 있으며, 링크의 방향이 존재한다. (양방향 x)           Ex) 에지 (u,v) != (v,u)
	* 에지 (u,v)는 u로부터 v로의 방향을 갖는다.

* 가중치 그래프
	* 에지마다 가중치(weight)가 지정된다.	       에지(링크)마다 값을 부여하는 것...

* 완전 그래프
	* 각 정점에서 다른 모든 정점을 연결하여 최대의 간선수를 갖는 그래프이다.   (무방향그래프에선 n(n-1)/2   방향 그래프에선 n(n-1)의 최대 간선을 갖을 수 있다.)
*/

#include<iostream>
#include<vector>
#include<string>

using namespace std;

int main()
{
	// 그래프의 표현 //

	// 인접행렬     ---> 정점의 개수 V개라고 했을 때, V*V크기의 이차원 배열을 이용한다.     * 저장공간 O(V^2)     * 어떤노드에 인접한 모든 노드찾기 O(n)     * 어떤에지 (u,v)가 존재하는지 검사 O(1) 상수시간

	/*
		간선의 가중치가 존재하지 않을 경우      A[i][j] = 1; (i -> j 간선이 존재할 경우)
											 A[i][j] = 0; (i -> j 간선이 존재하지 않을 경우)
	*/
	const int v = 10; // 정점이 10개라고 가정할 시
	int e = 10; // 간선이 10개라고 가정할 시
	int g[v + 1][v + 1]; // 10*10 2차원 배열 생성

	for (int i = 0; i < v + 1; ++i)
	{
		int x, y;
		cin >> x >> y;

		// 양뱡향 그래프일 경우 (x,y와 y,x 동일)
		g[x][y] = g[y][x] = 1;

		// 방향 그래프일 경우 (x,y와 y,x 동일하지 않으므로 한쪽만 1 대입)
		g[x][y] = 1;
	}

	/*
		간선의 가중치가 존재하는 경우 따로 다시 2차원배열을 통해 표현한다.
	*/
	const int v = 10; // 정점이 10개라고 가정할 시
	int e = 10; // 간선이 10개라고 가정할 시
	int g[v + 1][v + 1]; // 10*10 2차원 배열 생성
	int B[v + 1][v + 1]; // 가중치 배열
	int W = 123; // 가중치
	for (int i = 0; i < v + 1; ++i)
	{
		int x, y;
		cin >> x >> y;

		// 양뱡향 그래프일 경우 (x,y와 y,x 동일)
		g[x][y] = g[y][x] = 1;
		B[x][y] = B[y][x] = W;

		// 방향 그래프일 경우 (x,y와 y,x 동일하지 않으므로 한쪽만 1 대입)
		g[x][y] = 1;
	}


	// 인접리스트           저장공간  O(E) 주로 다루는 그래프틑 E < V 이므로 인접리스트가 효율적이다.   어떤노드의 인접한 노드 다 찾기 그 정점의 연결리스트 개수에 비례, 어떤에지가 존재하는지 연결리스트에 비례
	// 각 정점 집합을 표현하는 하나의 배열과 각정점마다 인접한 정점 연결리스트
	const int v = 10; // 정점의 개수
	int e = 10; // 간선의 개수
	vector<pair<int, int>>graph[v + 1];
	for (int i = 0; i < e; ++i)
	{
		int u, v, w; // 에지가 방향이 있고 (u,v)  가중치가 w일 경우
		cin >> u >> v >> w;

		graph[u].push_back(make_pair(v, w)); // 만약 무방향 일 경우 graph[v].push_back(make_pair(u,w)); 도 같이 타이핑 해주면 된다.
	}




	return 0;
}