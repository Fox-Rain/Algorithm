// Hashing          ( Hash table )
/*
	헤쉬테이블은 dynamic Set을 구현하는 효과적인 방법중에 하나이다.     "적절한 가정하에 평균탐색, 삽입, 삭제 시간복잡도가 O(1)로 상수시간이다."     "보통 최악의 경우가 O(N)"

	* 해쉬함수 h을 사용하여서 키K을 T[h(k)]에 저장한다.
		* h : u -> {0,1,2,3 ... m-1}   즉, 여기서 m은 헤쉬테이블의 크기, u는 모든 가능한 키값들의 집합을 의미한다.
		* h(k)   ==  키 k가 h(k)로 헤슁되었다고 말한다.         즉, 각 키에 대한 해쉬함수값을 그 키를 저장할 배열 인덱스로 사용한다는 것이다.  (해쉬테이블은 일반적으로 하나의 배열이다.)
		* index = h(k)

	* 모든 키들을 자연수로 가정.  어떤 데이터든지 자연수로 해석하는것이 가능하다.
		* Ex) 문자열 등... 모두 ASCII CODE를 통해서 자연수로 해석이 가능하기 때문

	* 해쉬함수의 간단한 예
		* h(k) = k % m    즉, key를 하나의 자연수로 해석한뒤 테이블의 크기 m으로 나눈 나머지   (따라서 테이블의 index는 0 ~ m-1 임)  항상 0 ~ m-1 사이의 정수가 된다.
		* 즉, 예를 들어서 m은 100인데  key값이 1024가 들어온다면 헤슁이 일어나게되면 24의 인덱스에 1024값이 들어가게 될것이다.  즉, 찾을 때에도 상수시간이 걸리게됨. < 인덱스안에 키값이 하나일 경우... >
		* ( Ex)) 1024 % 100 은 24므로  index = 24을 indexing하여서 값이 있는지 유무만 파악하면 되므로, 맨처음 계산하는 시간복잡도만 생각하여서 O(1)이 걸리게 된다.)
	그런데 위와같이 간단히 인덱스에 키값이 하나가 들어가게되는 경우는 거의 없다.

	* 충돌 ( collision )
		* 두 개 이상의 키가 동일한 인덱스 위치로 헤슁되는 경우를 말한다.
		* 즉, 서로다른 두키가 h(k1) == h(k2)인 상황
		* 그렇다고해서 헤쉬함수의 헤쉬테이블을 겹치지않게 크게만드는것은 비현실적이다.      (* 동일한 해쉬함수값을 갖는건 피할 수 없다.)
		* 따라서 충돌이 발생할때 따로 대처방법이 힐요한데  대표적인 두가지 충돌해결방법이 있다,  ---> *****   "chainning과 open addressing"   *****

	* chainning에 의한 충돌 해결          (by 연결리스트)
	  동일한 해슁인덱스에 들어가게 되는 키값들을 연결리스트로 만들어서 저장한다. (해쉬테이블에 첫번째 노드의 주소만 저장하고 나머지는 밖으로 연결리스트를 통해 연결하는 식...)
		* 키의 삽입 (insert)
			* 키 k를 리스트 T[h(k)]에 맨앞에 삽입   O(1)
			* 중복키가 들어올 수도 있고, 중복저장을 허용하지 않는다면 연결하기위해 리스트를 검색해야함 (리스트는 인덱싱이 불가능하므로 순차접근) 따라서 시간복잡도는 리스트의 길이에 비례하게 된다. O(n) n은 리스트길이
			* 중복을 허용한다면 그냥 연결하면 되므로 O(1)
		* 키의 검색 (search)
			* 해슁 인덱스에서의 연결리스트에서 순차검색...  시간복잡도는 리스트의 길이에 비례하게된다.
		* 키의 삭제 (delete)
			* 연결리스트에서 검색 후 삭체하므로  일단 검색시 리스트 길이에 비례할 것이고, 삭제는 연결리스트므로 O(1)의 시간복잡도 일것이다. 따라서  시간복잡도는 O(n) n은 리스트의 길이
		* 최악의 경우 == 모든키가 하나의 슬롯(하나의 인덱스)로 해슁되는 경우
			* 인덱스의 연결리스트 길이 == 전체 원소의 길이    따라서 최악의 경우  탐색시간 O(N) + 해쉬함수 계산시간이 되어서 매우 퍼포먼스가 저하될 수 있다.
			* 즉, 평균시간복잡도는 얼마나 키들이 해슁을 통해 여러 인덱스에 잘 분배되느냐에 따라서 결정되게 된다.

	* SUHA  (simple uniform hashing assumption) <- 해슁에 대해 이야기할때 이런식으로 가정을하고 이야기한다. (Default Assume)
		* 각각의 키가 모든 슬롯에 균등한 확률로 동립적으로 해슁된다는 가정이다.
			* 성능분석을 위해 하는 가정으로 현실에서는 불가능한 가정이다.
			* Load fatctor a = n/m : n(테이블에 저장될 키의 개수), m(헤쉬테이블크기(즉, 연결리스트의 개수), Load factor는 각 슬롯에 저장되는 키의 평균 개수를 의미함.

	* Open Addressing에 의한 충돌 해결    ( Linear probing   Quadratic probing   Double hasing )
		* 모든 키를 해쉬테이블에 저장 단, 테이블의 각 인덱스에 1개의 키만 저장한다.
		* Open Addressing의 기법들 -> Linear probing    Quadratic probing    Double hasing

		* Linear probing
			* 헤슁한 인덱스에 키값이 아직 없을을 경우 그냥 넣는다.   단, 만약 인덱스안에 키값이 이미 존재할 경우 Linear적으로 인덱스를 하나씩 증가시키면서 맨처음으로 비어있는 인덱스에 키값을 넣는다.
			* h(k), h(k)+1, h(k)+2 ... 순차로검색하여 처음으로 빈슬롯에 저장함  만약 테이블의 끝에 도달하게되면 다시처음으로 circular하게 돌아간다.  Ex) ( 0 ~ 9 ) 순차검색하다 9에 도착시 0으로 다시 화귀하여 실행
			* Lienar probing의 단점
				* 연속된슬롯(cluster) 이런 cluster가 생성되면 더 cluster가 점점더 커지는 경향이 생긴다. (이렇게되면 한 덩어리가 길어지게 되므로 search등을 시행할 때 더 퍼포먼스 저하가 심해진다.)
			* Linear probing에서의 Search
				* 1. 해슁한인덱스에서 값을 찾는다.    2. 찾는값이 아닐시 인덱스를 +1를 하면서 찾는다.   3. 만약 빈칸이 나올때까지 찾지 못했다면 그값은 존재하지않는것이다.

		* Quadratic probing        <--- Linear Probing의 cluster단점을 보안하기위해서 생겨난 알고리즘
			* 충돌발생시 h(k), h(k)+1^2, h(k)+2^2, h(k)+3^2 .... 순서로 시도해본다.       ( * cluster가 생기는것을 방지 할 수 있긴하다.. 떨어진 위치를 시도하게 되므로 )

		* Double hashing
			* 서로다른 두 해쉬함수 h1, h2를 이용하여서  h(k,i) = (h1(k) + i*h2(k)) mod m .... 불규칙적 시도로 cluster 완화

		* Open Addressing 키의삭제    <-- 단순이 키를 삭제할 경우 문제가 발생한다. (일반적인 chainning을 통한 충돌해결은 괜찮지만 Open Addressing의 경우 문제생김)
			* 키를 그냥 삭제하게되면 빈칸으로 남게되고, 빈칸으로 남게되면 Search할 경우 빈칸을 만나고 없다고 오판할 가능성이 있기 때문이다.
			* 즉, 삭제하고난뒤 원래 해쉬값들의 자리를 당겨주어야한다.

	* 좋은 해쉬함수란?
		* 현실에서는 키들이 랜덤히 일정하지 않음  따라서 키들이 어떤 특정한 패턴을 가지더라도 해쉬함수값이 불규칙적이게 되도록하는것이 바람직하다. (해쉬함수값이 키의 특정부분에 의해서만 결정되지 않도록 해야함)

	*/