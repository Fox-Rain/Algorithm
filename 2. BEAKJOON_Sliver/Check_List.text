< 백준 실버 문자열 >

1181   sort(iterator fist, iterator second, compare(함수))   <- 함수에 따라 sort가 어떻게 실행되는지 다시보기



5397   string은 문자열로 초기화하지 않았을시  기본적으로 크기가 15이다.    string.resize()  메모리할당 + 모든 원소를 " "로 채움   vs    string.reserve() 메모리할당만  한다는 점에서 다르다.
      
      *** vector에서 insert 메소드는 insert할 vector가 size가 작을지라도 size + 1를 늘리고 insert를 실행하기 때문에 원소범위에 따른 런타임에러가 발생하지 않는다.  (틀렸을 수 있으므로 다시 찾아보기)
      
      vector의 경우 삽입,삭제에 비효율적이다. (삽입 삭제가 일어날 때마다 끝원소에서 target원소까지의 거리(N)만큼의 step이 필요하므로 O(N) 시간복잡도가 좀 큰 편이다.)

      list에서 Ex) list.erase(--iterator) (X) 의 경우 erase나 insert의 경우 iterator가 변하기 때문에   다시 대입을 해주는 과정이 필요하다   iterator=list.erase(--iterator); (O)



10610  문자인 정수를 숫자로 나타내기  문자인숫자 - '0' 를 통하여 문자로 나타낼 수 있고,    atoi()는 문자열을 숫자로 바꾸어준다. (자릿수까지 계산해준다.)



7785   *** 중복되는 값들을 피하고 저장하는 컨테이너를 원한다면  set자료구조를 사용하는것이 좋다.

       *** string의 경우는 " " 빈칸이 입력될 경우, 스트림 읽기를 끝낸다  Ex) string name;  string imformation;  cin>>name>>imformation;  입력이 네이버 it시총1위 라면    name엔 네이버가, imformation엔 it시총1위 가 들어가게 된다.

       *** <algorithm>의 sort는 연속된컨테이너(vector,list,deque)등에서만 이용할 수 있으므로 unordered_set, unordered_map에서 이용하기 위해선 vector로 복사해서 옮긴뒤 sort해야 한다.

       vector에 복사하여 옮기는법  vector vec; 이라면  vec.insert(vec.end(), unodered_set.begin(), unordered_set.end()); 이런식으로 insert하여 복사하는 방법이 있다.   (push_back도 되겠지요...??)



11656  for(int i=0;i<str.length();++i)   <-- 이런 for문의 경우  조건 i<str.length() 에서 str.length()는 str의 길이가 바뀜에 따라 달라질 수 있는 것에 유의해야 한다.



9375   map에서는 iterator로 접근시   -> first 로  키값에   -> second 로 값에 접근할 수 있다.



1543   <string> 에서의 메소드 .find()는  find(찾는문자열,찾기시작할 index);     <--- 만약 찾는문자열을 찾을 경우 그 문자열이 시작하는 index를, 찾지못하였을 경우 -1을 리턴한다.



1032   *** vector<pair< , >> vec;   pair<>을 vector로 넣게되면  값을 2개씩 저장할 수 있습니다. ( map(키값과 값을 가진 연관컨테이너)을 vector로 복사하여 옮길때 사용할 수 있습니다.)

       sort(iterator.begin(),iterator.end(),Compare);   Compare는 함수로써 sort정렬의 기준을 선언할 수 있습니다.
       
       bool Compare( int A, int B )            <--- ***** 이러한 예시에선   A>B는 큰것부터 정렬,  A<B는 작은것부터 정렬한다는 의미입니다. *****
       {
            A>B;                
       }
